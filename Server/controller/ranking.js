import Player from "../models/player.js";
import Round from "../models/round.js";


export const createPlayer = async(req, res) =>{
    try {

        const {name, lastName, email, age, gender, contactNumber, utrLevel} = req.body;

        if (!name || !lastName || !email || !age || !gender || !contactNumber || !utrLevel) {
            return res.status(400).json({ error: "All fields are required" });
        }

        //obtener ultima ronda
        const latestRound = await Round.findOne().sort({roundNumber: -1});

        let newRank = null;

        if(latestRound){
            const highestRank = await Player.findOne().sort({ranking: -1});
            newRank = highestRank ? highestRank.ranking + 1 : 1
        }
        
        const player = new Player({
            name,
            lastName,
            email,
            age,
            gender,
            contactNumber,
            utrLevel,
            internalLevel: utrLevel,
            ranking: newRank,
            createdBy: req.admin?._id || null
        });

        //save DB
        await player.save();

        res.status(201).json({
            message: 'Player successfully created',
            player
        });

        await player.save();


    } catch (error) {
        res.status(400).json({
            error: error.message,
            errors: error.errors || null
        })
    }
}

// export const generateFirstRound = async(req, res) =>{
    
//     try{

//         const players = await Player.find({active: true}).lean()

//         if (players.length < 10) return res.status(400).json({error: 'Not enough players to start ranking'})

//         //sort UTR asc

//         const sorted = [...players].sort((a, b) => a.utrLevel - b.utrLevel)
//         const matches = []
//         const byePlayers = []

//         const used = new Set();

//         for (let i = 0; i < sorted.length; i++) {
//             if(used.has(i)) continue;

//             let player1 = sorted[i];
//             let bestMatchIndex  = -1;
//             let bestDiff = Infinity;

//             for(let j = i + 1; j < sorted.length; j++){
//                 if(used.has(j)) continue;

//                 const player2  = sorted[j];

//                 const utrDif = Math.abs(player1.utrLevel - player2.utrLevel)

//                 //gender rule

//                 const genderCompatible = 
//                     player1.gender === player2.gender ||
//                     (player1.gender === "M" && player2.gender === "F" && player2.utrLevel >= player1.utrLevel) ||
//                     (player1.gender === "F" && player2.gender === "M" && player1.utrLevel >= player2.utrLevel); 

//                 if (genderCompatible && utrDif < bestDiff){
//                     bestDiff = utrDif;
//                     bestMatchIndex = j
//                 }
//             }

//             if(bestMatchIndex !== -1){
//                 used.add(i)
//                 used.add(bestMatchIndex)
//                 matches.push({player1, player2: sorted[bestMatchIndex]})
//             }
//         }

//         sorted.forEach((p, idx) =>{
//             if(!used.has(idx)) byePlayers.push(p)
//         })

//             res.status(200).json({
//             message: "First round generated by UTR and gender balance",
//             totalPlayers: players.length,
//             totalMatches: matches.length,
//             byePlayers: byePlayers.map(p => `${p.name} ${p.lastName}`),
//             matches: matches.map(m => ({
//                 player1: `${m.player1.name} (${m.player1.gender}, ${m.player1.utrLevel})`,
//                 player2: `${m.player2.name} (${m.player2.gender}, ${m.player2.utrLevel})`
//             }))
//         });
//     }
    
//     catch(error){
//         res.status(500).json({ error: error.message });
//     }

// }